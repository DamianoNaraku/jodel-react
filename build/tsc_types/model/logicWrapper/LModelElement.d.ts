import type { LVoidVertex, PackagePointers, AttributePointers, EnumPointers, LiteralPointers, OperationPointers, ObjectPointers, ParameterPointers, ReferencePointers, ModelPointers, LtoD } from "../../joiner";
import { ClassPointers, Constructor, Constructors, DEdge, Dictionary, DocString, DPointerTargetable, DState, getWParams, GObject, GraphSize, LEdge, LGraphElement, LogicContext, LPointerTargetable, Pack, Pack1, PackArr, Pointer, RuntimeAccessibleClass } from "../../joiner";
import type { Info, Json, ObjectWithoutPointers, orArr, PrimitiveType, unArr } from "../../joiner/types";
import { AccessModifier } from "../../api/data";
import { ValuePointers } from "./PointerDefinitions";
export declare class DModelElement extends DPointerTargetable {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    id: Pointer<DModelElement, 1, 1, LModelElement>;
    parent: Pointer<DModelElement, 0, 'N', LModelElement>;
    father: Pointer<DModelElement, 1, 1, LModelElement>;
    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation>;
    static new(): DModelElement;
    static new3(...a: any): DModelElement;
}
export declare class DAnnotationDetail extends DPointerTargetable {
}
export declare class LModelElement<Context extends LogicContext<DModelElement> = any, D extends DModelElement = DModelElement> extends LPointerTargetable {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    __raw: DModelElement;
    id: Pointer<DModelElement, 1, 1, LModelElement>;
    parent: LModelElement[];
    father: LModelElement;
    private __info_of__father;
    fatherList: LModelElement[];
    annotations: LAnnotation[];
    children: (LPackage | LClassifier | LTypedElement | LAnnotation | LObject | LValue)[];
    __info_of_children__: Info;
    nodes: LGraphElement[];
    node: LGraphElement | undefined;
    model: LModel;
    package: LPackage | null;
    class: LClass | null;
    enum: LEnumerator | null;
    operation: LOperation | null;
    subNodes: LGraphElement[] | null;
    property: keyof DModelElement;
    containers: LNamedElement[];
    name?: string;
    [key: `@${string}`]: LModelElement;
    [key: `$${string}`]: LModelElement;
    protected _defaultSetter(val: any, c: GObject<Context>, k: any): true;
    protected _setterFor$stuff_canReturnFalse(val: any, c: Context, k: keyof Context["data"] & string): boolean;
    childNames: string[];
    __info_of__childNames: Info;
    get_childNames(c: Context): string[];
    generateEcoreJson(loopDetectionloopDetectionObj?: Dictionary<Pointer, DModelElement>): Json;
    private get_generateEcoreJson;
    protected generateEcoreJson_impl(context: Context, loopDetectionObj?: Dictionary<Pointer, DModelElement>): Json;
    duplicate(deep?: boolean): this;
    addAnnotation(source?: DAnnotation["source"], details?: DAnnotation["details"]): DAnnotation;
    protected get_addAnnotation(context: Context): this["addAnnotation"];
    protected set_containers(): boolean;
    protected get_containers(context: Context): LModelElement["containers"];
    protected get_namespace(context: Context): string;
    protected get_subNodes(context: LogicContext<LClass>, includingthis?: boolean): LGraphElement[];
    protected get_property(context: Context): this["property"];
    protected targetRemoved(context: Context, field: keyof DPointerTargetable): void;
    protected get_fatherList(context: Context): LModelElement[];
    private get_until_parent;
    protected get_nodes(context: Context): this["nodes"];
    protected get_node(context: Context): this["node"];
    protected get_model(context: Context): LModel;
    protected get_package(context: Context): LPackage;
    protected get_class(context: Context): LClass | null;
    protected get_operation(context: Context): LOperation | null;
    protected get_enum(context: Context): LEnumerator | null;
    protected get_father(context: Context): LModelElement;
    protected get_children_idlist(context: Context): Pointer<DAnnotation | DPackage | DClassifier | DEnumerator | DEnumLiteral | DParameter | DStructuralFeature | DOperation | DObject | DValue, 1, 'N'>;
    protected get_children(context: Context): this["children"];
    protected set_children(a: never, context: Context): boolean;
    add_parent(val: Pack<this["parent"]>, logicContext: Context): boolean;
    protected remove_parent(logicContext: Context): boolean;
    protected get_parent(context: Context): this["parent"];
    protected set_parent(val: Pack<LAnnotation>, context: Context): boolean;
    add_annotation(val: Pack<this["annotations"]>, context: Context): boolean;
    remove_annotation(val: Pack<this["annotations"]>, context: Context): boolean;
    protected get_annotations(context: Context): this["annotations"];
    protected set_annotations(val: Pack<LAnnotation>, context: Context): boolean;
    protected get_addChild(c: Context): (type?: string, ...params: any[]) => LModelElement;
    protected get_addException(context: Context): () => void;
    protected cannotCall(name: string, ...params: string[]): any;
    addClass(): void;
    addAttribute(): void;
    addReference(): void;
    addEnumerator(): void;
    addParameter(): void;
    addException(exception?: DClassifier): () => void;
    addChild(type: string): DModelElement;
}
export declare class DAnnotation extends DModelElement {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    id: Pointer<DAnnotation, 1, 1, LAnnotation>;
    parent: Pointer<DModelElement, 0, 'N', LModelElement>;
    father: Pointer<DModelElement, 1, 1, LModelElement>;
    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation>;
    source: string;
    details: DAnnotationDetail[];
    static new(source?: DAnnotation["source"], details?: DAnnotation["details"], father?: Pointer, persist?: boolean): DAnnotation;
}
export declare class LAnnotation<Context extends LogicContext<DAnnotation> = any, D extends DAnnotation = DAnnotation> extends LModelElement {
    __namee: "LAnnotation";
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    __raw: DAnnotation;
    id: Pointer<DAnnotation, 1, 1, LAnnotation>;
    parent: LModelElement[];
    father: LModelElement;
    annotations: LAnnotation[];
    source: string;
    details: LAnnotationDetail[];
    protected generateEcoreJson_impl(context: Context, loopDetectionObj?: Dictionary<Pointer, DModelElement>): Json;
    duplicate(deep?: boolean): this;
    protected get_duplicate(context: Context): ((deep?: boolean) => this);
    protected get_source(context: Context): this["source"];
    protected set_source(val: this["source"], context: Context): boolean;
    protected get_details(context: Context): this["details"];
    protected set_details(val: this["details"], context: Context): boolean;
}
export declare class LAnnotationDetail<Context extends LogicContext<DAnnotationDetail> = any> extends LModelElement {
    father: LAnnotation;
    protected generateEcoreJson_impl(context: Context, loopDetectionObj?: Dictionary<Pointer, DModelElement>): Json;
    duplicate(deep?: boolean): this;
    protected get_duplicate(context: Context): ((deep?: boolean) => this);
}
export declare class DNamedElement extends DPointerTargetable {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    id: Pointer<DNamedElement, 1, 1, LNamedElement>;
    parent: Pointer<DModelElement, 0, 'N', LModelElement>;
    father: Pointer<DModelElement, 1, 1, LModelElement>;
    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation>;
    name: string;
    static new(name?: DNamedElement["name"]): DNamedElement;
}
export declare class LNamedElement<Context extends LogicContext<DNamedElement> = any> extends LModelElement {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    id: Pointer<DNamedElement, 1, 1, LNamedElement>;
    parent: LModelElement[];
    father: LModelElement;
    annotations: LAnnotation[];
    name: string;
    namespace: string;
    fullname: string;
    protected set_containers(): boolean;
    protected get_containers(context: Context): LNamedElement["containers"];
    protected get_fullname(context: Context): this["fullname"];
    protected get_name(context: Context): this["name"];
    protected set_name(val: this["name"], context: Context): boolean;
    protected _autofix_name(val: string, context: Context): string;
    protected get_autofix_name(val: string, context: Context): (val: string) => string;
    autofix_name(val: string): string;
}
export declare class DTypedElement extends DPointerTargetable {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    id: Pointer<DTypedElement, 1, 1, LTypedElement>;
    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation>;
    parent: Pointer<DModelElement, 0, 'N', LModelElement>;
    father: Pointer<DModelElement, 1, 1, LModelElement>;
    name: string;
    instances: Pointer<DValue, 0, 'N', LValue>;
    type: Pointer<DClassifier, 1, 1, LClassifier>;
    ordered: boolean;
    unique: boolean;
    lowerBound: number;
    upperBound: number;
    many: boolean;
    required: boolean;
    static new(name?: DNamedElement["name"], type?: DTypedElement["type"], father?: Pointer, persist?: boolean): DTypedElement;
}
export declare class LTypedElement<Context extends LogicContext<DTypedElement> = any> extends LNamedElement {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    __raw: DTypedElement;
    id: Pointer<DTypedElement, 1, 1, LTypedElement>;
    parent: LModelElement[];
    father: LModelElement;
    annotations: LAnnotation[];
    name: string;
    namespace: string;
    instances: LValue[];
    type: LClassifier;
    primitiveType?: LClass;
    classType?: LClass;
    enumType?: LEnumerator;
    ordered: boolean;
    unique: boolean;
    lowerBound: number;
    upperBound: number;
    many: boolean;
    required: boolean;
    protected get_classType(context: Context): this["classType"];
    protected get_enumType(context: Context): this["enumType"];
    protected get_primitiveType(context: Context): this["primitiveType"];
    protected get_type(context: Context): this["type"];
    protected set_type(val: Pack1<this["type"]>, context: Context): boolean;
    protected get_ordered(context: Context): this["ordered"];
    protected set_ordered(val: this["ordered"], logicContext: Context): boolean;
    protected get_unique(context: Context): this["unique"];
    protected set_unique(val: this["unique"], logicContext: Context): boolean;
    protected get_lowerBound(context: Context): this["lowerBound"];
    protected set_lowerBound(val: this["lowerBound"], context: Context): boolean;
    protected get_upperBound(context: Context): this["upperBound"];
    protected set_upperBound(val: this["upperBound"], context: Context): boolean;
    protected get_many(context: Context): this["many"];
    protected set_many(val: this["many"], context: Context): boolean;
    protected get_required(context: Context): this["required"];
    protected set_required(val: this["required"], context: Context): boolean;
    typeToEcoreString(): string;
    protected get_typeToEcoreString(context: Context): () => string;
    typeToShortString(): string;
    protected get_typeToShortString(context: Context): () => string;
    canOverride(context: Context, other: LTypedElement): boolean;
}
export declare class DClassifier extends DPointerTargetable {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    id: Pointer<DClassifier, 1, 1, LClassifier>;
    parent: Pointer<DPackage, 0, 'N', LPackage>;
    father: Pointer<DPackage, 1, 1, LPackage>;
    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation>;
    name: string;
    instanceClassName: string;
    defaultValue: Pointer<DObject, 1, 1, LObject>[] | string[];
    static new(name?: DNamedElement["name"], father?: Pointer, persist?: boolean): DClassifier;
}
export declare class LClassifier<Context extends LogicContext<DClassifier> = any> extends LNamedElement {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    __raw: DClassifier;
    id: Pointer<DClassifier, 1, 1, LClassifier>;
    parent: LPackage[];
    father: LPackage;
    annotations: LAnnotation[];
    name: string;
    namespace: string;
    instanceClassName: string;
    defaultValue: LObject[] | string[];
    isPrimitive: boolean;
    isClass: boolean;
    isEnum: boolean;
    protected get_instanceClassName(context: Context): this["instanceClassName"];
    protected set_instanceClassName(val: this["instanceClassName"], context: Context): boolean;
    protected set_isPrimitive(val: this["isPrimitive"], context: Context): boolean;
    protected set_isClass(val: this["isClass"], context: Context): boolean;
    protected set_isEnum(val: this["isEnum"], context: Context): boolean;
    protected get_isPrimitive(context: Context): this["isPrimitive"];
    protected get_isClass(context: Context): this["isClass"];
    protected get_isEnum(context: Context): this["isEnum"];
    protected set_defaultValue(val: this["defaultValue"] | DClassifier["defaultValue"], context: Context): boolean;
    typeEcoreString: string;
    typeString: string;
    private get_typeEcoreString;
    private get_typeString;
}
export declare class DPackage extends DPointerTargetable {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    id: Pointer<DPackage, 1, 1, LPackage>;
    parent: Pointer<DPackage | DModel, 0, 'N', LPackage | LModel>;
    father: Pointer<DPackage | DModel, 1, 1, LPackage | LModel>;
    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation>;
    name: string;
    classifiers: Pointer<DClassifier, 0, 'N', LClassifier>;
    subpackages: Pointer<DPackage, 0, 'N', LPackage>;
    uri: string;
    prefix: string;
    static new(name?: DNamedElement["name"], uri?: DPackage["uri"], prefix?: DPackage["prefix"], father?: Pointer, persist?: boolean, fatherType?: Constructor): DPackage;
    static new3(a: Partial<PackagePointers>, callback: undefined | ((d: DPackage, c: Constructors) => void), fatherType: Constructor, persist?: boolean): DPackage;
}
export declare class LPackage<Context extends LogicContext<DPackage> = any, C extends Context = Context, D extends DPackage = DPackage> extends LNamedElement {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    __raw: DPackage;
    id: Pointer<DPackage, 1, 1, LPackage>;
    parent: (LPackage | LModel)[];
    father: LPackage | LModel;
    annotations: LAnnotation[];
    name: string;
    namespace: string;
    classifiers: LClassifier[];
    subpackages: LPackage[];
    uri: string;
    prefix: string;
    classes: LClass[] & Dictionary<DocString<"$name">, LClass>;
    enums: LEnumerator[] & Dictionary<DocString<"$name">, LEnumerator>;
    enumerators: LEnumerator[];
    allSubPackages: LPackage[];
    allSubEnums: LEnumerator[];
    allSubClasses: LClass[];
    operations: LOperation[];
    parameters: LParameter[];
    exceptions: LClassifier[];
    attributes: LAttribute[];
    references: LReference[];
    literals: LEnumLiteral[];
    protected generateEcoreJson_impltemplate(context: Context, loopDetectionObj?: Dictionary<Pointer, DModelElement>): Json;
    protected generateEcoreJson_impl(context: Context, loopDetectionObj?: Dictionary<Pointer, DModelElement>): Json;
    duplicate(deep?: boolean): this;
    protected get_duplicate(context: Context): ((deep?: boolean) => LPackage);
    addPackage(name?: D["name"], uri?: D["uri"], prefix?: D["prefix"]): LPackage;
    protected get_addPackage(context: Context): this["addPackage"];
    addClass(name?: DClass["name"], isInterface?: DClass["interface"], isAbstract?: DClass["abstract"], isPrimitive?: DClass["isPrimitive"], isPartial?: DClass["partial"], partialDefaultName?: DClass["partialdefaultname"]): LClass;
    protected get_addClass(context: Context): this["addClass"];
    addEnum(...p: Parameters<this["addEnumerator"]>): LEnumerator;
    protected get_addEnum(context: Context): this["addEnumerator"];
    addEnumerator(name?: DEnumerator["name"]): LEnumerator;
    protected get_addEnumerator(context: Context): this["addEnumerator"];
    protected get_classes(context: Context, state?: DState, setNameKeys?: boolean): LClass[] & Dictionary<DocString<"$name">, LClass>;
    protected get_enums(context: Context): (LEnumerator[] & Dictionary<DocString<"$name">, LEnumerator>);
    protected get_enumerators(context: Context, state?: DState, setNameKeys?: boolean): (LEnumerator[] & Dictionary<DocString<"$name">, LEnumerator>);
    private get_allSubClasses;
    private get_allSubEnums;
    private get_allSubEnumerators;
    private get_allSubPackages;
    protected get_children_idlist(context: Context): Pointer<DAnnotation | DPackage | DClassifier, 1, 'N'>;
    protected get_classifiers(context: Context): this["classifiers"];
    protected set_classifiers(val: PackArr<this["classifiers"]>, context: Context): boolean;
    protected get_subpackages(context: Context): this["subpackages"];
    protected set_subpackages(val: PackArr<this["subpackages"]>, context: Context): boolean;
    protected get_uri(context: Context): this["uri"];
    protected set_uri(val: this["uri"], context: Context): boolean;
    protected get_prefix(context: Context): this["uri"];
    protected set_prefix(val: this["prefix"], context: Context): boolean;
}
export declare class DOperation extends DPointerTargetable {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    instances: never[];
    id: Pointer<DOperation, 1, 1, LObject>;
    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation>;
    parent: Pointer<DClass, 0, 'N', LClass>;
    father: Pointer<DClass, 1, 1, LClass>;
    name: string;
    type: Pointer<DClassifier, 1, 1, LClassifier>;
    ordered: boolean;
    unique: boolean;
    lowerBound: number;
    upperBound: number;
    many: boolean;
    required: boolean;
    exceptions: Pointer<DClassifier, 0, 'N', LClassifier>;
    parameters: Pointer<DParameter, 0, 'N', LParameter>;
    visibility: AccessModifier;
    implementation: string;
    static new(name?: DNamedElement["name"], type?: DOperation["type"], exceptions?: DOperation["exceptions"], father?: DOperation["father"], persist?: boolean): DOperation;
    static new2(setter: Partial<ObjectWithoutPointers<DOperation>>, father: DOperation["father"], type?: DOperation["type"], name?: string): DOperation;
    static new3(a: Partial<OperationPointers>, callback: undefined | ((d: DOperation, c: Constructors) => void), persist?: boolean): DOperation;
}
export declare class LOperation<Context extends LogicContext<DOperation> = any, C extends Context = Context, D extends DOperation = DOperation> extends LTypedElement {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    __raw: DOperation;
    id: Pointer<DOperation, 1, 1, LOperation>;
    instances: never[];
    annotations: LAnnotation[];
    parent: LClass[];
    father: LClass;
    name: string;
    namespace: string;
    type: LClassifier;
    ordered: boolean;
    unique: boolean;
    lowerBound: number;
    upperBound: number;
    many: boolean;
    required: boolean;
    implementation: string;
    signatureImplementation: string;
    exceptions: LClassifier[];
    parameters: LParameter[];
    visibility: AccessModifier;
    protected generateEcoreJson_impl(context: Context, loopDetectionObj?: Dictionary<Pointer, DModelElement>): Json;
    duplicate(deep?: boolean): this;
    protected get_duplicate(context: Context): ((deep?: boolean) => LOperation);
    addParameter(name?: DParameter["name"], type?: DParameter["type"]): LParameter;
    protected get_addParameter(context: Context): this["addParameter"];
    execute(thiss: LObject, ...params: any): any;
    protected get_execute(context: Context): ((thiss: LObject, ...params: any[]) => any);
    set_implementation(val: this["implementation"], context: Context): boolean;
    get_implementation(context: Context): this["implementation"];
    set_signatureImplementation(val: this["signatureImplementation"], context: Context): boolean;
    get_signatureImplementation(context: Context, typedComments?: boolean): this["signatureImplementation"];
    get_signature(context: Context): this["signatureImplementation"];
    protected get_children_idlist(context: Context): Pointer<DAnnotation | DClassifier | DParameter, 1, 'N'>;
    protected get_exceptions(context: Context): this["exceptions"];
    protected set_exceptions(val: PackArr<this["exceptions"]>, context: Context): boolean;
    protected get_parameters(context: Context): this["parameters"];
    protected set_parameters(val: PackArr<this["parameters"]>, context: Context): boolean;
    _mark(b: boolean, superchildren: LOperation, override: string): void;
    _canOverride(superchildren: LOperation): undefined;
    _canPolymorph(superchildren: LOperation): undefined;
}
export declare class DParameter extends DPointerTargetable {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    instances: never[];
    id: Pointer<DParameter, 1, 1, LParameter>;
    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation>;
    parent: Pointer<DOperation, 0, 'N', LOperation>;
    father: Pointer<DOperation, 1, 1, LOperation>;
    name: string;
    type: Pointer<DClassifier, 1, 1, LClassifier>;
    ordered: boolean;
    unique: boolean;
    lowerBound: number;
    upperBound: number;
    many: boolean;
    required: boolean;
    defaultValue: any;
    static new(name?: DNamedElement["name"], type?: DTypedElement["type"], father?: Pointer, persist?: boolean): DParameter;
    static new2(setter: Partial<ObjectWithoutPointers<DParameter>>, father: DParameter["father"], type?: DParameter["type"], name?: DParameter["name"]): DParameter;
    static new3(a: Partial<ParameterPointers>, callback: undefined | ((d: DParameter, c: Constructors) => void), persist?: boolean): DParameter;
}
export declare class LParameter<Context extends LogicContext<DParameter> = any, C extends Context = Context, D extends DParameter = DParameter> extends LTypedElement {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    __raw: DParameter;
    id: Pointer<DParameter, 1, 1, LParameter>;
    instances: never[];
    annotations: LAnnotation[];
    parent: LOperation[];
    father: LOperation;
    name: string;
    namespace: string;
    type: LClassifier;
    ordered: boolean;
    unique: boolean;
    lowerBound: number;
    upperBound: number;
    many: boolean;
    required: boolean;
    defaultValue: any;
    protected generateEcoreJson_impl(context: Context, loopDetectionObj?: Dictionary<Pointer, DModelElement>): Json;
    duplicate(deep?: boolean): this;
    protected get_duplicate(context: Context): ((deep?: boolean) => LParameter);
}
export declare class ClassReferences {
    id?: Pack1<LClass>;
    parent?: this["father"][];
    father?: Pack1<LPackage>;
    instances?: Pointer<DObject, 0, 'N', LObject>;
    operations?: Pointer<DOperation, 0, 'N', LOperation>;
    features?: Pointer<DStructuralFeature, 0, 'N', LStructuralFeature>;
    references?: Pointer<DReference, 0, 'N', LReference>;
    attributes?: Pointer<DAttribute, 0, 'N', LAttribute>;
    referencedBy?: Pointer<DReference, 0, 'N', LReference>;
    extends?: Pointer<DClass, 0, 'N', LClass>;
    extendedBy?: Pointer<DClass, 0, 'N', LClass>;
    implements?: Pointer<DClass, 0, 'N', LClass>;
    implementedBy?: Pointer<DClass, 0, 'N', LClass>;
}
export declare class DClass extends DPointerTargetable {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    id: Pointer<DClass, 1, 1, LClass>;
    instanceClassName: string;
    parent: Pointer<DPackage, 0, 'N', LPackage>;
    father: Pointer<DPackage, 1, 1, LPackage>;
    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation>;
    name: string;
    defaultValue: Pointer<DObject, 1, 1, LObject>[];
    abstract: boolean;
    interface: boolean;
    instances: Pointer<DObject, 0, 'N', LObject>;
    operations: Pointer<DOperation, 0, 'N', LOperation>;
    features: Pointer<DStructuralFeature, 0, 'N', LStructuralFeature>;
    references: Pointer<DReference, 0, 'N', LReference>;
    attributes: Pointer<DAttribute, 0, 'N', LAttribute>;
    referencedBy: Pointer<DReference, 0, 'N', LReference>;
    extends: Pointer<DClass, 0, 'N', LClass>;
    extendedBy: Pointer<DClass, 0, 'N', LClass>;
    isPrimitive: boolean;
    implements: Pointer<DClass, 0, 'N', LClass>;
    implementedBy: Pointer<DClass, 0, 'N', LClass>;
    partial: boolean;
    partialdefaultname: string;
    static new(name?: DNamedElement["name"], isInterface?: DClass["interface"], isAbstract?: DClass["abstract"], isPrimitive?: DClass["isPrimitive"], partial?: DClass["partial"], partialDefaultName?: DClass["partialdefaultname"], father?: Pointer, persist?: boolean, id?: string): DClass;
    static new2(setter: Partial<ObjectWithoutPointers<DClass>>, father: DClass["father"], name?: DClass["name"]): DClass;
    static new3(a: Partial<ClassPointers>, callback: undefined | ((d: DClass, c: Constructors) => void), persist?: boolean): DClass;
}
export declare class LClass<D extends DClass = DClass, Context extends LogicContext<DClass> = any, C extends Context = Context> extends LClassifier {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    __raw: DClass;
    id: Pointer<DClass, 1, 1, LClass>;
    instanceClassName: string;
    parent: LPackage[];
    father: LPackage;
    annotations: LAnnotation[];
    name: string;
    namespace: string;
    defaultValue: LObject[];
    abstract: boolean;
    interface: boolean;
    instances: LObject[];
    operations: LOperation[];
    features: LStructuralFeature[];
    references: LReference[];
    attributes: LAttribute[];
    referencedBy: LReference[];
    extends: LClass[];
    __info_of__extends: Info;
    extendsChain: LClass[];
    extendedBy: LClass[];
    nodes: LGraphElement[];
    superclasses: LClass[];
    __info_of__superclasses: Info;
    allSubClasses: LClass[];
    partial: boolean;
    partialdefaultname: string;
    isPrimitive: boolean;
    isClass: boolean;
    isEnum: false;
    implements: Pointer<DClass, 0, 'N', LClass>;
    implementedBy: Pointer<DClass, 0, 'N', LClass>;
    ownAttributes: LAttribute[];
    ownReferences: LReference[];
    ownOperations: LOperation[];
    ownChildren: (LStructuralFeature | LOperation)[];
    inheritedAttributes: LAttribute[];
    inheritedReferences: LReference[];
    inheritedOperations: LOperation[];
    inheritedChildren: (LStructuralFeature | LOperation)[];
    allAttributes: LAttribute[];
    allReferences: LReference[];
    allOperations: LOperation[];
    allChildren: (LStructuralFeature | LOperation)[];
    exceptions: LClassifier[] | null;
    parameters: LParameter[] | null;
    get_childNames(c: Context): string[];
    protected get_ownAttributes(context: Context): this['ownAttributes'];
    protected get_ownReferences(context: Context): this['ownReferences'];
    protected get_ownOperations(context: Context): this['ownOperations'];
    protected get_ownChildren(context: Context): this['ownChildren'];
    private get_extendsChain;
    isSubClassOf(superClass: LClass, returnIfSameClass?: boolean): boolean;
    isSuperClassOf(subClass: LClass, returnIfSameClass?: boolean): boolean;
    protected get_isSubClassOf(c: Context): ((superClass: LClass, returnIfSameClass?: boolean) => boolean);
    protected get_isSuperClassOf(c: Context): ((subClass: LClass, returnIfSameClass?: boolean) => boolean);
    protected get_inheritedAttributes(context: Context): this['inheritedAttributes'];
    protected get_inheritedReferences(context: Context): this['inheritedReferences'];
    protected get_inheritedOperations(context: Context): this['inheritedOperations'];
    protected get_inheritedChildren(context: Context): this['inheritedChildren'];
    protected get_allAttributes(context: Context): this['allAttributes'];
    protected get_allReferences(context: Context): this['allReferences'];
    protected get_allOperations(context: Context): this['allOperations'];
    protected get_allChildren(context: Context): this['allChildren'];
    protected generateEcoreJson_impl(context: Context, loopDetectionObj?: Dictionary<Pointer, DModelElement>): Json;
    duplicate(deep?: boolean): this;
    protected get_duplicate(context: Context): ((deep?: boolean) => LClass);
    protected get_children_idlist(context: Context): Pointer<DAnnotation | DStructuralFeature | DOperation, 1, 'N'>;
    protected set_name(val: this["name"], context: Context): boolean;
    protected set_partial(val: D["partial"], context: Context): boolean;
    protected get_partial(context: Context): D["partial"];
    protected set_partialdefaultname(val: D["partialdefaultname"], context: Context): boolean;
    protected get_partialdefaultname(context: Context): D["partialdefaultname"];
    addAttribute(name?: DAttribute["name"], type?: DAttribute["type"]): LAttribute;
    protected get_addAttribute(context: Context): this["addAttribute"];
    addReference(name?: DReference["name"], type?: DReference["type"]): LReference;
    protected get_addReference(context: Context): this["addReference"];
    addOperation(name?: DOperation["name"], type?: DOperation["type"]): LOperation;
    protected get_addOperation(context: Context): this["addOperation"];
    protected get_abstract(context: Context): this["abstract"];
    protected set_abstract(val: this["abstract"], context: Context): boolean;
    protected set_isPrimitive(val: this["isPrimitive"], context: Context): boolean;
    protected get_interface(context: Context): this["interface"];
    protected set_interface(val: this["interface"], context: Context): boolean;
    protected get_instances(context: Context): this["instances"];
    protected set_instances(val: PackArr<this["instances"]>, context: Context): boolean;
    protected get_operations(context: Context): this["operations"];
    protected set_operations(val: PackArr<this["operations"]>, context: Context): boolean;
    protected get_features(context: Context): this["features"];
    protected set_features(val: PackArr<this["features"]>, context: Context): boolean;
    protected get_references(context: Context): this["references"];
    protected set_references(val: PackArr<this["references"]>, context: Context): boolean;
    protected get_attributes(context: Context): this["attributes"];
    protected set_attributes(val: PackArr<this["attributes"]>, context: Context): boolean;
    protected get_referencedBy(context: Context): this["referencedBy"];
    protected set_referencedBy(val: PackArr<this["referencedBy"]>, context: Context): boolean;
    protected get_extends(context: Context): this["extends"];
    protected set_extends(val: PackArr<this["extends"]>, context: Context): boolean;
    protected add_extends(val: PackArr<this["extends"]>, context: Context): void;
    protected remove_extends(val: PackArr<this["extends"]> | number | number[], context: Context): void;
    protected get_extendedBy(context: Context): this["extendedBy"];
    protected set_extendedBy(val: PackArr<this["extendedBy"]>, context: Context): boolean;
    protected get_implements(context: Context): this["implements"];
    protected set_implements(val: this["implements"], context: Context): boolean;
    protected get_implementedBy(context: Context): this["implementedBy"];
    protected set_implementedBy(val: this["implementedBy"], context: Context): boolean;
    canExtend(superclass: LClass, output?: {
        reason: string;
        allTargetSuperClasses: LClass[];
    }): boolean;
    private get_canExtend;
    isExtending(superclass: Pack1<LClass>, directly?: boolean): boolean;
    isSubclassOf(superclass: Pack1<LClass>, directly?: boolean): boolean;
    __info_of__isSubclassOf: Info;
    __info_of__isExtending: Info;
    private get_isSubclassOf;
    private get_isExtending;
    private get_superclasses;
    private get_allSubClasses;
    private _canExtend;
    private _isExtending;
    private add_Extends;
    unsetExtends(context: Context, superclass: LClass): void;
    instance(): DObject;
}
export declare class DDataType extends DPointerTargetable {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    id: Pointer<DDataType, 1, 1, LDataType>;
    instanceClassName: string;
    parent: Pointer<DPackage, 0, 'N', LPackage>;
    father: Pointer<DPackage, 1, 1, LPackage>;
    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation>;
    name: string;
    defaultValue: Pointer<DObject, 1, 1, LObject>[] | string[];
    serializable: boolean;
    static new(name?: DNamedElement["name"], father?: Pointer, persist?: boolean): DDataType;
}
export declare class LDataType<Context extends LogicContext<DDataType> = any, C extends Context = Context> extends LClassifier {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    __raw: DDataType;
    id: Pointer<DDataType, 1, 1, LDataType>;
    instanceClassName: string;
    parent: LPackage[];
    father: LPackage;
    annotations: LAnnotation[];
    name: string;
    namespace: string;
    defaultValue: LObject[] | string[];
    isPrimitive: false;
    isClass: false;
    isEnum: true;
    serializable: boolean;
    protected get_serializable(context: Context): this["serializable"];
    protected set_serializable(val: this["serializable"], context: Context): boolean;
}
export declare class DStructuralFeature extends DPointerTargetable {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    id: Pointer<DStructuralFeature, 1, 1, LStructuralFeature>;
    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation>;
    parent: Pointer<DClass, 0, 'N', LClass>;
    father: Pointer<DClass, 1, 1, LClass>;
    name: string;
    type: Pointer<DClassifier, 1, 1, LClassifier>;
    ordered: boolean;
    unique: boolean;
    lowerBound: number;
    upperBound: number;
    many: boolean;
    required: boolean;
    instances: Pointer<DValue, 0, 'N', LValue>;
    changeable: boolean;
    volatile: boolean;
    transient: boolean;
    unsettable: boolean;
    derived: boolean;
    defaultValue: (Pointer<DObject, 1, 1, LObject> | PrimitiveType)[];
    static new(name?: DNamedElement["name"], type?: DTypedElement["type"], father?: Pointer, persist?: boolean): DStructuralFeature;
}
export declare class LStructuralFeature<Context extends LogicContext<DStructuralFeature> = any, C extends Context = Context> extends LTypedElement {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    __raw: DStructuralFeature;
    id: Pointer<DStructuralFeature, 1, 1, LStructuralFeature>;
    annotations: LAnnotation[];
    parent: LClass[];
    father: LClass;
    name: string;
    namespace: string;
    type: LClassifier;
    ordered: boolean;
    unique: boolean;
    lowerBound: number;
    upperBound: number;
    many: boolean;
    required: boolean;
    instances: LValue[];
    changeable: boolean;
    volatile: boolean;
    transient: boolean;
    unsettable: boolean;
    derived: boolean;
    defaultValue: (LObject[] | PrimitiveType[]);
    protected get_instances(context: Context): this["instances"];
    protected set_instances(val: PackArr<this["instances"]>, context: Context): boolean;
    protected get_changeable(context: Context): this["changeable"];
    protected set_changeable(val: this["changeable"], context: Context): boolean;
    protected get_volatile(context: Context): this["volatile"];
    protected set_volatile(val: this["volatile"], context: Context): boolean;
    protected get_transient(context: Context): this["transient"];
    protected set_transient(val: this["transient"], context: Context): boolean;
    protected get_unsettable(context: Context): this["unsettable"];
    protected set_unsettable(val: this["unsettable"], context: Context): boolean;
    protected get_derived(context: Context): this["derived"];
    protected set_derived(val: this["derived"], context: Context): boolean;
}
export declare class DReference extends DPointerTargetable {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    id: Pointer<DReference, 1, 1, LReference>;
    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation>;
    name: string;
    type: Pointer<DClass, 1, 1, LClass>;
    ordered: boolean;
    unique: boolean;
    lowerBound: number;
    upperBound: number;
    many: boolean;
    required: boolean;
    changeable: boolean;
    volatile: boolean;
    transient: boolean;
    unsettable: boolean;
    derived: boolean;
    defaultValueLiteral: string;
    parent: Pointer<DClass, 0, 'N', LClass>;
    father: Pointer<DClass, 1, 1, LClass>;
    instances: Pointer<DValue, 0, 'N', LValue>;
    defaultValue: Pointer<DObject, 1, 1, LObject>[];
    containment: boolean;
    container: boolean;
    resolveProxies: boolean;
    opposite?: Pointer<DReference>;
    target: Pointer<DClass, 0, 'N', LClass>;
    edges: Pointer<DEdge, 0, 'N', LEdge>;
    static new(name?: DReference["name"], type?: DReference["type"], father?: DReference["father"], persist?: boolean): DReference;
    static new2(setter: Partial<ObjectWithoutPointers<DReference>>, father: DReference["father"], type?: DReference["type"], name?: DReference["name"]): DReference;
    static new3(a: Partial<ReferencePointers>, callback: undefined | ((d: DReference, c: Constructors) => void), persist?: boolean): DReference;
}
export declare class LReference<Context extends LogicContext<DReference> = any, C extends Context = Context, D extends DReference = DReference> extends LStructuralFeature {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    __raw: DReference;
    id: Pointer<DReference, 1, 1, LReference>;
    annotations: LAnnotation[];
    name: string;
    namespace: string;
    type: LClass;
    ordered: boolean;
    unique: boolean;
    lowerBound: number;
    upperBound: number;
    many: boolean;
    required: boolean;
    changeable: boolean;
    volatile: boolean;
    transient: boolean;
    unsettable: boolean;
    derived: boolean;
    defaultValueLiteral: string;
    parent: LClass[];
    father: LClass;
    instances: LValue[];
    defaultValue: LObject[];
    containment: boolean;
    container: boolean;
    resolveProxies: boolean;
    opposite?: LReference;
    edges: LEdge[];
    protected generateEcoreJson_impl(context: Context, loopDetectionObj?: Dictionary<Pointer, DModelElement>): Json;
    duplicate(deep?: boolean): this;
    protected get_duplicate(context: Context): ((deep?: boolean) => LReference);
    protected set_type(val: Pack1<this["type"]>, context: Context): boolean;
    addClass(name?: DClass["name"], isInterface?: DClass["interface"], isAbstract?: DClass["abstract"], isPrimitive?: DClass["isPrimitive"], isPartial?: DClass["partial"], partialDefaultName?: DClass["partialdefaultname"]): LClass;
    protected get_addClass(context: Context): this["addClass"];
    protected get_containment(context: Context): this["containment"];
    protected set_containment(val: this["containment"], context: Context): boolean;
    protected get_container(context: Context): this["container"];
    protected set_container(val: this["container"], context: Context): boolean;
    protected get_resolveProxies(context: Context): this["resolveProxies"];
    protected set_resolveProxies(val: this["resolveProxies"], context: Context): boolean;
    protected get_opposite(context: Context): this["opposite"];
    protected set_opposite(val: Pack<LReference | undefined>, context: Context): boolean;
    protected get_defaultValue(context: Context): this["defaultValue"];
    protected set_defaultValue(val: PackArr<this["defaultValue"]>, context: Context): boolean;
    protected get_edges(context: Context): this["edges"];
    protected set_edges(val: PackArr<this["edges"]>, context: Context): boolean;
}
export declare class DAttribute extends DPointerTargetable {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    id: Pointer<DAttribute, 1, 1, LAttribute>;
    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation>;
    name: string;
    type: Pointer<DClassifier, 1, 1, LClassifier>;
    ordered: boolean;
    unique: boolean;
    lowerBound: number;
    upperBound: number;
    many: boolean;
    required: boolean;
    changeable: boolean;
    volatile: boolean;
    transient: boolean;
    unsettable: boolean;
    derived: boolean;
    defaultValueLiteral: string;
    parent: Pointer<DClass, 0, 'N', LClass>;
    father: Pointer<DClass, 1, 1, LClass>;
    instances: Pointer<DValue, 0, 'N', LValue>;
    defaultValue: PrimitiveType[];
    isID: boolean;
    static new(name?: DAttribute["name"], type?: DAttribute["type"], father?: DAttribute["father"], persist?: boolean): DAttribute;
    static new2(setter: Partial<ObjectWithoutPointers<DReference>>, father: DAttribute["father"], type?: DAttribute["type"], name?: DAttribute["name"]): DAttribute;
    static new3(a: Partial<AttributePointers>, callback: undefined | ((d: DAttribute, c: Constructors) => void), persist?: boolean): DAttribute;
}
export declare class LAttribute<Context extends LogicContext<DAttribute> = any, C extends Context = Context, D extends DAttribute = DAttribute> extends LStructuralFeature {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    __raw: DAttribute;
    id: Pointer<DAttribute, 1, 1, LAttribute>;
    annotations: LAnnotation[];
    name: string;
    namespace: string;
    type: LClassifier;
    ordered: boolean;
    unique: boolean;
    lowerBound: number;
    upperBound: number;
    many: boolean;
    required: boolean;
    changeable: boolean;
    volatile: boolean;
    transient: boolean;
    unsettable: boolean;
    derived: boolean;
    defaultValue: PrimitiveType[];
    parent: LClass[];
    father: LClass;
    instances: LValue[];
    isID: boolean;
    protected generateEcoreJson_impl(context: Context, loopDetectionObj?: Dictionary<Pointer, DModelElement>): Json;
    duplicate(deep?: boolean): this;
    protected get_duplicate(context: Context): ((deep?: boolean) => LAttribute);
    addEnum(...p: Parameters<this["addEnumerator"]>): LEnumerator;
    protected get_addEnum(context: Context): this["addEnumerator"];
    addEnumerator(name?: DEnumerator["name"], father?: DEnumerator["father"]): LEnumerator;
    protected get_addEnumerator(context: Context): this["addEnumerator"];
    protected get_ID(context: Context): this["isID"];
    protected set_ID(val: this["isID"], context: Context): boolean;
    protected get_defaultValue(context: Context): this["defaultValue"];
    protected set_defaultValue(val: unArr<this["defaultValue"]>, context: Context): boolean;
}
export declare class DEnumLiteral extends DPointerTargetable {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    id: Pointer<DEnumLiteral, 1, 1, LEnumLiteral>;
    parent: Pointer<DEnumerator, 0, 'N', LEnumerator>;
    father: Pointer<DEnumerator, 1, 1, LEnumerator>;
    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation>;
    name: string;
    value: number;
    literal: string;
    static new(name?: DNamedElement["name"], value?: DEnumLiteral["value"], father?: Pointer, persist?: boolean): DEnumLiteral;
    static new2(setter: Partial<ObjectWithoutPointers<DEnumLiteral>>, father: DEnumLiteral["father"], name?: DEnumLiteral["name"]): DEnumLiteral;
    static new3(a: Partial<LiteralPointers>, callback: undefined | ((d: DEnumLiteral, c: Constructors) => void), persist?: boolean): DEnumLiteral;
}
export declare class LEnumLiteral<Context extends LogicContext<DEnumLiteral> = any, C extends Context = Context, D extends DEnumLiteral = DEnumLiteral> extends LNamedElement {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    __raw: DEnumLiteral;
    id: Pointer<DEnumLiteral, 1, 1, LEnumLiteral>;
    parent: LEnumerator[];
    father: LEnumerator;
    annotations: LAnnotation[];
    name: string;
    namespace: string;
    value: this["ordinal"];
    ordinal: number;
    literal: string;
    protected generateEcoreJson_impl(context: Context, loopDetectionObj?: Dictionary<Pointer, DModelElement>): Json;
    generateEcoreJsonM1(): this["ordinal"];
    protected get_generateEcoreJsonM1(context: Context): () => this["ordinal"];
    protected impl_generateEcoreJsonM1(context: Context): () => this["ordinal"];
    duplicate(deep?: boolean): this;
    protected get_duplicate(context: Context): ((deep?: boolean) => LEnumLiteral);
    protected get_ordinal(context: Context): this["ordinal"];
    protected set_ordinal(val: this["ordinal"], context: Context): boolean;
    protected get_value(context: Context): this["value"];
    protected set_value(val: this["value"], context: Context): boolean;
    protected get_literal(context: Context): this["literal"];
    protected set_literal(val: this["literal"], context: Context): boolean;
}
export declare class DEnumerator extends DPointerTargetable {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    id: Pointer<DEnumerator, 1, 1, LEnumerator>;
    instanceClassName: string;
    parent: Pointer<DPackage, 0, 'N', LPackage>;
    father: Pointer<DPackage, 1, 1, LPackage>;
    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation>;
    name: string;
    defaultValue: string[];
    serializable: boolean;
    literals: Pointer<DEnumLiteral, 0, 'N', LEnumLiteral>;
    static new(name?: DNamedElement["name"], father?: DEnumerator["father"], persist?: boolean): DEnumerator;
    static new2(setter: Partial<ObjectWithoutPointers<DEnumerator>>, father: DEnumerator["father"], name?: DEnumerator["name"]): DEnumerator;
    static new3(a: Partial<EnumPointers>, callback: undefined | ((d: DEnumerator, c: Constructors) => void), persist?: boolean): DEnumerator;
}
export declare class LEnumerator<Context extends LogicContext<DEnumerator> = any, C extends Context = Context, D extends DEnumerator = DEnumerator> extends LDataType {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    __raw: DEnumerator;
    id: Pointer<DEnumerator, 1, 1, LEnumerator>;
    instanceClassName: string;
    parent: LPackage[];
    father: LPackage;
    annotations: LAnnotation[];
    name: string;
    namespace: string;
    defaultValue: string[];
    serializable: boolean;
    isPrimitive: false;
    isClass: false;
    isEnum: true;
    literals: LEnumLiteral[];
    ordinals: LEnumLiteral[];
    protected generateEcoreJson_impl(context: Context, loopDetectionObj?: Dictionary<Pointer, DModelElement>): Json;
    duplicate(deep?: boolean): this;
    protected get_duplicate(context: Context): ((deep?: boolean) => LEnumerator);
    protected get_children_idlist(context: Context): Pointer<DAnnotation | DEnumLiteral, 1, 'N'>;
    addLiteral(name?: DEnumLiteral["name"], value?: DEnumLiteral["value"]): LEnumLiteral;
    protected get_addLiteral(context: Context): this["addLiteral"];
    protected get_literals(context: Context): this["literals"];
    protected set_literals(val: PackArr<this["literals"]>, context: Context): boolean;
    protected get_ordinals(context: Context): this["ordinals"];
}
export declare class DModelM1 extends DNamedElement {
    name: string;
    roots: Pointer<DObject, 1, 'N', LObject>;
    children: DModelM1["roots"];
}
export declare class LModelM1 extends LNamedElement {
    name: string;
    roots: LObject[];
    children: LModelM1["roots"];
}
export declare class DModel extends DNamedElement {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    id: Pointer<DModel, 1, 1, LModel>;
    parent: Pointer<DModelElement, 0, 'N', LModelElement>;
    father: Pointer<DModelElement, 1, 1, LModelElement>;
    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation>;
    name: string;
    packages: Pointer<DPackage, 0, 'N', LPackage>;
    isMetamodel: boolean;
    objects: Pointer<DObject, 0, 'N', LObject>;
    models: Pointer<DModel, 0, 'N', LModel>;
    instanceof?: Pointer<DModel>;
    static new(name?: DNamedElement["name"], instanceoff?: DModel["instanceof"], isMetamodel?: DModel["isMetamodel"], persist?: boolean): DModel;
    static new2(setter: Partial<ObjectWithoutPointers<DModel>>, name?: DModel["name"], instanceoff?: DModel["instanceof"]): DModel;
    static new3(a: Partial<ModelPointers>, callback: undefined | ((d: DModel, c: Constructors) => void), persist?: boolean): DModel;
}
export declare class EdgeStarter<T1 = any, T2 = any> {
    start: LModelElement;
    end: LModelElement;
    startNode: LGraphElement;
    endNode: LGraphElement;
    startVertex: LVoidVertex;
    endVertex: LVoidVertex;
    startSize: GraphSize;
    endSize: GraphSize;
    startVertexSize: GraphSize;
    endVertexSize: GraphSize;
    otherEnds: LGraphElement[];
    overlaps: boolean;
    vertexOverlaps: boolean;
    constructor(start: LModelElement, end: LModelElement, sn: LGraphElement, en: LGraphElement, otherPossibleEnds?: LGraphElement[]);
    static oneToMany<T1 extends LModelElement = LModelElement, T2 extends LModelElement = LModelElement>(start: T1, ends: T2[]): EdgeStarter<T1, T2>[];
}
export declare class LModel<Context extends LogicContext<DModel> = any, C extends Context = Context, D extends DModel = DModel> extends LNamedElement {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    __raw: DModel;
    id: Pointer<DModel, 1, 1, LModel>;
    parent: LModel[];
    father: LModel;
    annotations: LAnnotation[];
    name: string;
    namespace: string;
    isMetamodel: boolean;
    packages: LPackage[];
    models: LModel[];
    instanceof?: LModel;
    objects: LObject[];
    roots: LObject[];
    enums: LEnumerator[] & Dictionary<DocString<"$name">, LEnumerator>;
    enumerators: LEnumerator[] & Dictionary<DocString<"$name">, LEnumerator>;
    classes: LClass[] & Dictionary<DocString<"$name">, LClass>;
    operations: LOperation[];
    parameters: LParameter[];
    exceptions: LClassifier[];
    attributes: LAttribute[];
    references: LReference[];
    literals: LEnumLiteral[];
    values: LValue[];
    allSubAnnotations: LAnnotation[];
    allSubPackages: LPackage[];
    allSubObjects: LObject[];
    allSubValues: LValue[];
    suggestedEdges: {
        extend: EdgeStarter[];
        reference: EdgeStarter[];
        packageDependencies: EdgeStarter[];
    };
    __info_of__suggestedEdges: Info;
    protected generateEcoreJson_impl(context: Context, loopDetectionObj?: Dictionary<Pointer, DModelElement>): Json;
    addPackage(name?: DPackage["name"], uri?: DPackage["uri"], prefix?: DPackage["prefix"]): LPackage;
    get_addPackage(context: Context): ((name?: DPackage["name"], uri?: DPackage["uri"], prefix?: DPackage["prefix"]) => LPackage);
    static namesORDObjectsToID<T extends DPointerTargetable = DPointerTargetable>(a: T): Pointer<T>[];
    static namesORDObjectsToID<T extends DPointerTargetable = DPointerTargetable>(a: T[]): Pointer<T>[];
    static namesORDObjectsToID<L extends LPointerTargetable = LPointerTargetable>(a: L): Pointer<LtoD<L>>[];
    static namesORDObjectsToID<L extends LPointerTargetable = LPointerTargetable>(a: L[]): Pointer<LtoD<L>>[];
    static namesORDObjectsToID<T extends DPointerTargetable = DPointerTargetable>(a: Pointer<T>): Pointer<T>[];
    static namesORDObjectsToID<T extends DPointerTargetable = DPointerTargetable>(a: Pointer<T>[]): Pointer<T>[];
    static namesORDObjectsToID(a: string, namedCandidates: LModelElement[]): Pointer[];
    static namesORDObjectsToID(a: string[], namedCandidates: LModelElement[]): Pointer[];
    static namesORDObjectsToID(a: string | LClass | DClass | Pointer, namedCandidates: LModelElement[]): Pointer[];
    static namesORDObjectsToID(a: (string | LClass | DClass | Pointer)[], namedCandidates: LModelElement[]): Pointer[];
    static namesORDObjectsToID<T extends DPointerTargetable = DPointerTargetable>(a: orArr<(string | T | Pointer<T>)>): Pointer<T>[];
    _defaultGetter(c: Context, key: string): any;
    _defaultGetterM2(c: Context, key: string): any;
    _defaultGetterM1(c: Context, key: string): any;
    private static otherObjectsTemp;
    private static otherObectsAccessedKeys;
    otherObjects: (excludeInstances: orArr<(string | LClass | Pointer)>, excludeSubclasses?: boolean) => LObject[];
    otherInstances: (excludeInstances: orArr<(string | LClass | Pointer)>, excludeSubclasses?: boolean) => LObject[];
    __info_of__otherObjects: Info;
    __info_of__otherInstances: Info;
    get_otherObjects(c: Context): (excludeInstances: orArr<(string | LClass | Pointer)>, excludeSubclasses?: boolean) => LObject[];
    get_otherInstances(c: Context): (excludeInstances: orArr<(string | LClass | Pointer)>, excludeSubclasses?: boolean) => LObject[];
    private _populateOtherObjects;
    instancesOf(instancetypes0: orArr<(string | LClass | Pointer)>, includeSubclasses?: boolean): LObject[];
    __type_of__instancesOf: Info;
    get_instancesOf(c: Context): (this["instancesOf"]);
    addObject(json: GObject, instanceoff?: LClass | Pointer<DClass> | DocString<"ClassName"> | undefined | null): ReturnType<LValue["addObject"]>;
    __info_of__addObject: Info;
    get_addObject(c: Context): ReturnType<LValue["get_addObject"]>;
    instantiableClasses(o?: GObject, loose?: boolean): LClass[];
    __info_of__instantiableClasses: Info;
    get_instantiableClasses(c: Context): LValue["instantiableClasses"];
    get_suggestedEdges(context: Context): this["suggestedEdges"];
    private impl_get_suggestedEdgesM1;
    private impl_get_suggestedEdgesM2;
    protected get_models(context: Context): LModel[];
    protected set_models(val: PackArr<this['models']>, context: Context): boolean;
    duplicate(deep?: boolean): this;
    protected set_instanceof(val: Pack1<this["instanceof"]>, context: Context): boolean;
    protected get_instanceof(context: Context): this["instanceof"];
    protected set_name(val: this['name'], context: Context): boolean;
    protected get_children_idlist(context: Context): Pointer<DAnnotation | (DPackage | DObject), 1, 'N'>;
    protected get_isMetamodel(context: Context): this['isMetamodel'];
    protected set_isMetamodel(val: this['isMetamodel'], context: Context): boolean;
    protected get_objects(context: Context): this['objects'];
    protected get_packages(context: Context): this["packages"];
    protected set_packages(val: PackArr<this["packages"]>, context: Context): boolean;
    protected get_roots(context: Context): this["roots"];
    protected get_classes(context: Context, s?: DState): this["classes"];
    protected get_references(context: Context, s?: DState): this["references"];
    protected get_enums(context: Context): this["enums"];
    protected get_enumerators(context: Context, s?: DState): this["enums"];
    protected get_allSubPackages(context: Context, state?: DState): this["allSubPackages"];
    protected get_allSubValues(context: Context, state?: DState): this["allSubValues"];
    protected get_allSubObjects(context: Context, state?: DState): this["allSubObjects"];
    getClassByNameSpace(namespacedclass: string): LClass | undefined;
    protected get_getClassByNameSpace(context: Context): this["getClassByNameSpace"];
    getPackageByUri(uri: string): LPackage | undefined;
    protected get_getPackageByUri(context: Context): this["getPackageByUri"];
    protected get_attributes(context: Context): this['attributes'];
    protected get_literals(context: Context): this['literals'];
    protected get_values(context: Context): this['values'];
}
export declare abstract class DFactory_useless_ extends DPointerTargetable {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    id: Pointer<DFactory_useless_, 1, 1, LFactory_useless_>;
    parent: Pointer<DModelElement, 0, 'N', LModelElement>;
    father: Pointer<DModelElement, 1, 1, LModelElement>;
    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation>;
    ePackage: Pointer<DPackage, 1, 1, LPackage>;
    abstract create(DClass: DClass): DObject;
    abstract createFromString(eDataType: DDataType, literalValue: string): EJavaObject;
    abstract convertFromString(eDataType: DDataType, instanceValue: EJavaObject): string;
}
export declare abstract class LFactory_useless_<Context extends LogicContext<DFactory_useless_> = any, C extends Context = Context> extends LModelElement {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    __raw: DFactory_useless_;
    id: Pointer<DFactory_useless_, 1, 1, LFactory_useless_>;
    parent: LModelElement[];
    father: LModelElement;
    annotations: LAnnotation[];
    ePackage: LPackage;
    abstract create(DClass: DClass): DObject;
    abstract createFromString(eDataType: DDataType, literalValue: string): EJavaObject;
    abstract convertFromString(eDataType: DDataType, instanceValue: EJavaObject): string;
}
export declare class EJavaObject {
}
export declare class DMap extends RuntimeAccessibleClass {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    __isDMap: true;
    constructor();
}
export declare class LMap<Context extends LogicContext<DMap> = any, C extends Context = Context> extends LPointerTargetable {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    __isLMap: true;
}
export declare class DObject extends DPointerTargetable {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    annotations: never[];
    id: Pointer<DObject, 1, 1, LObject>;
    parent: Pointer<DModel | DValue, 0, 'N', LModel | LValue>;
    father: Pointer<DModel, 1, 1, LModel> | Pointer<DValue, 1, 1, LValue>;
    name: string;
    instanceof: Pointer<DClass>;
    features: Pointer<DValue>[];
    static new(instanceoff?: DObject["instanceof"], father?: DObject["father"], fatherType?: typeof DModel | typeof DValue, name?: DNamedElement["name"], persist?: boolean): DObject;
    static new3(ptrs: Partial<ObjectPointers>, then: (d: DObject, c: Constructors) => void, fatherType?: typeof DModel | typeof DValue, persist?: boolean): DObject;
}
export declare class LObject<Context extends LogicContext<DObject> = any, C extends Context = Context, D extends DObject = DObject> extends LNamedElement {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    __raw: DObject;
    id: Pointer<DObject, 1, 1, LObject>;
    annotations: never[];
    children: LValue[];
    allChildren: LValue[];
    truechildren: LValue[];
    parent: (LModel | LValue)[];
    father: LModel | LValue;
    model: LModel;
    name: string;
    ecoreRootName: string;
    namespace: string;
    fullname: string;
    defaultValue: DClass["defaultValue"];
    deepSubObjects: LObject[];
    subObjects: LObject[];
    referenceFeatures: LValue[];
    attributeFeatures: LValue[];
    shapelessFeatures: LValue[];
    instanceof: LClass;
    features: LValue[];
    referencedBy: LObject[];
    isRoot: boolean;
    readonly partial: boolean;
    protected get_name(context: Context): this['name'];
    protected get_truechildren(context: Context): this["children"];
    protected get_allChildren(context: Context): this["children"];
    protected get_children(context: Context, sort?: boolean): this["children"];
    protected get_model(context: Context): LModelElement["model"];
    protected set_namespace(val: string, context: Context): boolean;
    protected set_fullname(val: string, context: Context): boolean;
    protected get_fullname(context: Context): LClass["fullname"];
    protected set_ecoreRootName(val: string, context: Context): boolean;
    protected get_ecoreRootName(context: Context): LObject["ecoreRootName"];
    protected set_partialdefaultname(val: DClass["partialdefaultname"], context: Context): boolean;
    protected get_partialdefaultname(context: Context): DClass["partialdefaultname"];
    protected set_partial(val: DClass["partial"], context: Context): boolean;
    protected get_partial(context: Context): DClass["partial"];
    protected set_defaultValue(val: string, context: Context): boolean;
    protected get_defaultValue(context: Context): LClass["defaultValue"];
    protected set_referencedBy(val: string, context: Context): boolean;
    protected get_referencedBy(context: Context): LObject["referencedBy"];
    protected get_subObjects(context: Context): this["subObjects"];
    protected get_deepSubObjects(context: Context): this["deepSubObjects"];
    protected get_referenceFeatures(context: Context, includeshapeless?: boolean): this["referenceFeatures"];
    protected get_attributeFeatures(context: Context, includeshapeless?: boolean): this["attributeFeatures"];
    protected get_shapelessFeatures(context: Context): this["shapelessFeatures"];
    protected get_isRoot(context: Context): LObject["isRoot"];
    protected set_isRoot(val: never, context: Context): boolean;
    feature(name: string): (PrimitiveType | LObject) | (PrimitiveType | LObject)[];
    private get_feature;
    protected generateEcoreJson_impl(context: Context, loopDetectionObj?: Dictionary<Pointer, DModelElement>): Json;
    addValue(name?: DValue["name"], instanceoff?: DValue["instanceof"], value?: DValue["values"], isMirage?: boolean): LValue;
    protected get_addValue(context: Context): this["addValue"];
    protected get_namespace(context: Context): string;
    protected get_uri(context: Context): string;
    protected get_children_idlist(context: Context): Pointer<DAnnotation | DValue, 1, 'N'>;
    protected get_instanceof(context: Context): this["instanceof"];
    protected set_instanceof(val: Pack1<this["instanceof"]>, context: Context): boolean;
    private forceConformity;
    private _forceConformity;
    private _removeConformity;
    protected get_features(context: Context): this['features'];
    ecorePointer(): string;
    protected get_ecorePointer(context: Context): () => string;
}
export declare class DValue extends DModelElement {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    id: Pointer<DValue, 1, 1, LValue>;
    parent: Pointer<DObject, 0, 'N', LObject>;
    father: Pointer<DObject, 1, 1, LObject>;
    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation>;
    name?: string;
    values: PrimitiveType[] | Pointer<DObject | DEnumLiteral, 1, 'N', LObject | LEnumLiteral>;
    instanceof: Pointer<DAttribute, 1, 1, LAttribute> | Pointer<DReference, 1, 1, LReference> | undefined;
    edges: Pointer<DEdge, 0, 'N', LEdge>;
    isMirage: boolean;
    topic: string;
    static new(name?: DNamedElement["name"], instanceoff?: DValue["instanceof"], val?: DValue["values"], father?: DValue["father"] | DObject, persist?: boolean, isMirage?: boolean): DValue;
    static new3(a: Partial<ValuePointers>, then?: ((d: DValue, c: Constructors) => void), persist?: boolean): DValue;
}
export declare class LValue<Context extends LogicContext<DValue> = any, C extends Context = Context, D extends DValue = DValue> extends LModelElement {
    static subclasses: (typeof RuntimeAccessibleClass | string)[];
    static _extends: (typeof RuntimeAccessibleClass | string)[];
    __raw: DValue;
    id: Pointer<DValue, 1, 1, LValue>;
    parent: (LObject | LModel)[];
    father: LObject | LModel;
    model: LModel;
    name: string;
    namespace: string;
    fullname: string;
    type: LClassifier;
    primitiveType: LClass;
    classType: LClass;
    enumType: LEnumerator;
    ordered: boolean;
    unique: boolean;
    lowerBound: number;
    upperBound: number;
    many: boolean;
    required: boolean;
    changeable: boolean;
    volatile: boolean;
    transient: boolean;
    unsettable: boolean;
    derived: boolean;
    defaultValue: DStructuralFeature["defaultValue"];
    containment: boolean;
    container: boolean;
    opposite?: LValue;
    edges: LEdge[];
    topic: string;
    value: PrimitiveType | LObject | LEnumLiteral;
    isMirage: boolean;
    values: PrimitiveType[] | LObject[] | LEnumLiteral[];
    instanceof: LAttribute | LReference | undefined;
    conformsTo: (LAttribute | LReference)[];
    protected _defaultGetter(c: Context, k: keyof Context["data"]): any;
    protected _defaultSetter(v: any, c: Context, k: keyof Context["data"]): true;
    add(...val: any[]): void;
    __info_of__add: Info;
    get_add(c: Context): (...val: any[] | this["values"]) => void;
    remove(...val: any[]): void;
    __info_of__remove: Info;
    get_remove(c: Context): (...val: this["values"]) => void;
    removeByIndex(...val: number[]): void;
    __info_of__removeByIndex: Info;
    get_removeByIndex(c: Context): (...indices: number[]) => void;
    instantiableClasses(o?: GObject, loose?: boolean): LClass[];
    __info_of__instantiableClasses: Info;
    get_instantiableClasses(c: Context): this["instantiableClasses"];
    static getInstantiableClasses(thiss: LValue, c: LogicContext<DValue> | LogicContext<DModel>, schema?: GObject, loose?: boolean, eligibleClasses?: LClass[], favoriteMatch?: LClass): LClass[];
    addObject(json?: GObject, metaclass?: LClass | Pointer<DClass> | DocString<"ClassName"> | undefined | null): LObject;
    __info_of__addObject: Info;
    get_addObject(c: LogicContext<DValue> | LogicContext<DModel>): (json: GObject) => LObject;
    protected get_edges(context: Context): this["edges"];
    protected get_fromlfeature<C, T extends keyof (NonNullable<C>)>(meta: C, key: T): NonNullable<C>[T];
    protected get_opposite(context: Context): LReference["opposite"];
    protected get_container(context: Context): LReference["container"];
    protected get_containment(context: Context): LReference["containment"];
    protected get_defaultValue(context: Context): LStructuralFeature["defaultValue"];
    protected get_defaultderived(context: Context): LStructuralFeature["derived"];
    protected get_defaultunsettable(context: Context): LStructuralFeature["unsettable"];
    protected get_defaulttransient(context: Context): LStructuralFeature["transient"];
    protected get_volatile(context: Context): LStructuralFeature["volatile"];
    protected get_changeable(context: Context): LStructuralFeature["changeable"];
    protected get_required(context: Context): LStructuralFeature["required"];
    protected get_unique(context: Context): LStructuralFeature["unique"];
    protected get_many(context: Context): LStructuralFeature["many"];
    protected get_upperBound(context: Context): LStructuralFeature["upperBound"];
    protected get_lowerBound(context: Context): LStructuralFeature["lowerBound"];
    protected get_ordered(context: Context): LStructuralFeature["ordered"];
    protected get_enumType(context: Context): LStructuralFeature["enumType"];
    protected get_classType(context: Context): LStructuralFeature["classType"];
    protected get_primitiveType(context: Context): LStructuralFeature["primitiveType"];
    protected get_type(context: Context): LStructuralFeature["type"];
    protected get_fullname(context: Context): LStructuralFeature["fullname"];
    protected get_namespace(context: Context): LStructuralFeature["namespace"];
    protected get_name(context: Context): LStructuralFeature["name"];
    protected get_instanceof(context: Context): this["instanceof"];
    protected set_instanceof(val: Pack1<this["instanceof"]>, context: Context): boolean;
    protected get_isMirage(context: Context): this["isMirage"];
    protected set_isMirage(val: this["isMirage"], context: Context): boolean;
    typeStr: string;
    typeString: string;
    __info_of__typeStr: Info;
    __info_of__typeString: Info;
    protected get_typeString(c: Context): string;
    protected get_typeStr(c: Context): string;
    protected get_value<T extends boolean>(context: Context, namedPointers?: boolean, ecorePointers?: boolean, shapeless?: boolean, keepempties?: boolean, withmetainfo?: T): T extends true ? ValueDetail : this["value"];
    getValue<T extends boolean>(namedPointers?: boolean, ecorePointers?: boolean, shapeless?: boolean, keepempties?: boolean, withmetainfo?: T): T extends true ? ValueDetail : this["value"];
    protected get_getValue(context: Context): this["getValue"];
    protected get_values<T extends boolean>(context: Context, fitSize?: boolean, namedPointers?: boolean, ecorePointers?: boolean, shapeless?: boolean, keepempties?: boolean, withmetainfo?: T, maxlimit?: number, solveLiterals?: "ordinals" | "literal_obj" | "literal_str" | "original"): (T extends undefined ? this["values"] : T extends false ? this["values"] : ValueDetail[]) & {
        type?: string;
    };
    getValues<T extends boolean>(fitSize?: boolean, namedPointers?: boolean, ecorePointers?: boolean, shapeless?: boolean, keepempties?: boolean, withmetainfo?: T, maxlimit?: number): (T extends undefined ? this["values"] : T extends false ? this["values"] : ValueDetail[]) & {
        type?: string;
    };
    protected get_getValues(context: Context): this["getValues"];
    valuesString(keepemptyquotes?: boolean): string;
    valuestring(keepemptyquotes?: boolean): string;
    private get_valuestring;
    private get_valuesString;
    private valuestring_impl;
    setValueAtPosition(index: number, val: this["values"][0], info?: Partial<SetValueAtPositionInfoType>): {
        success: boolean;
        reason?: string;
    };
    protected _clearValueAtPosition(context: Context, index: number, info0?: Partial<SetValueAtPositionInfoType>, skipSettingUndefined?: boolean): void;
    protected get_setValueAtPosition(context: Context): ((index: number, val: this["values"][0], info?: Partial<SetValueAtPositionInfoType>) => {
        success: boolean;
        reason?: string;
    });
    protected set_values(val: orArr<D["values"]>, context: Context): boolean;
    protected set_value(val: D["values"][0], context: Context): boolean;
    protected generateEcoreJson_impl(context: Context, loopDetectionObj?: Dictionary<Pointer, DModelElement>): Json;
    protected get_toString(context: Context): () => string;
    protected _toString(context: Context): string;
    rawValues(): void;
    get_rawValues(context: Context): this["values"];
    protected get_topic(context: Context): this["topic"];
    protected set_topic(val: string, context: Context): boolean;
}
export declare type ValueDetail = {
    value: LValue['value'];
    rawValue: DValue['values'][0];
    index: number;
    hidden: boolean;
};
export declare type SetValueAtPositionInfoType = {
    setMirage: boolean;
    isPtr: boolean;
    type: LValue['type'];
    instanceof: LValue['instanceof'];
    isContainment: boolean;
    fatherList: LValue['fatherList'];
};
export declare type WModelElement = getWParams<LModelElement, DModelElement>;
export declare type WModel = getWParams<LModel, DModel>;
export declare type WValue = getWParams<LValue, DValue>;
export declare type WNamedElement = getWParams<LNamedElement, DNamedElement>;
export declare type WObject = getWParams<LObject, DObject>;
export declare type WEnumerator = getWParams<LEnumerator, DEnumerator>;
export declare type WEnumLiteral = getWParams<LEnumLiteral, DEnumLiteral>;
export declare type WAttribute = getWParams<LAttribute, DAttribute>;
export declare type WReference = getWParams<LReference, DReference>;
export declare type WStructuralFeature = getWParams<LStructuralFeature, DStructuralFeature>;
export declare type WClassifier = getWParams<LClassifier, DClassifier>;
export declare type WDataType = getWParams<LDataType, DDataType>;
export declare type WClass = getWParams<LClass, DClass>;
export declare type WParameter = getWParams<LParameter, DParameter>;
export declare type WOperation = getWParams<LOperation, DOperation>;
export declare type WPackage = getWParams<LPackage, DPackage>;
export declare type WTypedElement = getWParams<LTypedElement, DTypedElement>;
export declare type WAnnotation = getWParams<LAnnotation, DAnnotation>;
export declare type WMap = getWParams<LMap, DMap>;
export declare type WFactory_useless_ = getWParams<LFactory_useless_, DFactory_useless_>;
